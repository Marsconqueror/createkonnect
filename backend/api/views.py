import random
from datetime import timedelta
from django.conf import settings
from django.contrib.auth import get_user_model
from django.contrib.auth.hashers import make_password
from django.core.mail import send_mail
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.db import IntegrityError, transaction
from django.db.models import Q
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, render
from django.utils import timezone

from rest_framework import serializers, status
from rest_framework.authentication import SessionAuthentication, TokenAuthentication
from rest_framework.decorators import api_view, authentication_classes, parser_classes, permission_classes
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView

from rest_framework_simplejwt.exceptions import InvalidToken, TokenError
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer, TokenRefreshSerializer
from rest_framework_simplejwt.settings import api_settings as jwt_settings
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView

from .models import (
    ChatMessage, 
    Group, 
    GroupMembership, 
    GroupMessage, 
    LogAction,
    LogBlock, 
    OTP, 
    Product, 
    Purchase, 
    VerificationRequest,
    add_log_entry
)
from .serializers import (
    ChatMessageSerializer,
    GroupDetailSerializer, 
    GroupListSerializer, 
    GroupMembershipSerializer, 
    GroupMessageSerializer, 
    GroupSerializer,
    ProductSerializer,
    UserProfileSerializer,
    UserProfileUpdateSerializer,
    UserSerializer
)

ACCESS_TOKEN_LIFETIME = timedelta(minutes=5) # Or use jwt_settings.ACCESS_TOKEN_LIFETIME
REFRESH_TOKEN_LIFETIME = timedelta(days=1)   # Or use jwt_settings.REFRESH_TOKEN_LIFETIME
COOKIE_HTTPONLY = True
COOKIE_SECURE = not settings.DEBUG # Set to True in production (requires HTTPS)
COOKIE_SAMESITE = 'Strict' # Or 'Lax'
ACCESS_TOKEN_COOKIE_NAME = 'access_token'
REFRESH_TOKEN_COOKIE_NAME = 'refresh_token'

User = get_user_model()

def sample_api(request):
    return JsonResponse({"message": "Hello from Django!"})

class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    @classmethod
    def get_token(cls, user):
        token = super().get_token(user)
        token['username'] = user.username  # Optional: Add extra data to token
        return token

class MyTokenObtainPairView(TokenObtainPairView):
    serializer_class = MyTokenObtainPairSerializer


# Serializer to handle user data
class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ["id", "username", "email", "password", "public_key", "phone_verified", "email_verified"]
        extra_kwargs = {"password": {"write_only": True}}  # Hide password in response

    def create(self, validated_data):
        validated_data["password"] = make_password(validated_data["password"])  # Hash password
        return super().create(validated_data)

# API endpoint to register users
class CookieTokenObtainPairSerializer(TokenObtainPairSerializer):
    # Optional: Add extra claims if needed, like in your original MyTokenObtainPairSerializer
    @classmethod
    def get_token(cls, user):
        token = super().get_token(user)
        token['username'] = user.username
        # Add other custom claims here if necessary
        return token

    def validate(self, attrs):
        # Generate tokens but don't include them in the response body
        data = super().validate(attrs)
        # Remove refresh and access tokens from the response data
        data.pop('refresh', None)
        data.pop('access', None)

        # Include user data if needed by the frontend upon login
        data['user'] = UserSerializer(self.user).data # Or UserProfileSerializer
        # Log login action
        add_log_entry(self.user, LogAction.USER_LOGIN, {'username': self.user.username})
        return data

class CookieTokenObtainPairView(TokenObtainPairView):
    serializer_class = CookieTokenObtainPairSerializer

    def finalize_response(self, request, response, *args, **kwargs):
        # If login is successful (status 200), set cookies
        if response.status_code == 200 and REFRESH_TOKEN_COOKIE_NAME in self.get_serializer().validated_data:
            refresh_token = self.get_serializer().validated_data.pop(REFRESH_TOKEN_COOKIE_NAME) # Retrieve token generated by serializer hook/signal
            access_token = self.get_serializer().validated_data.pop(ACCESS_TOKEN_COOKIE_NAME) # Retrieve token generated by serializer hook/signal

            response.set_cookie(
                key=ACCESS_TOKEN_COOKIE_NAME,
                value=access_token,
                expires=timezone.now() + ACCESS_TOKEN_LIFETIME,
                httponly=COOKIE_HTTPONLY,
                secure=COOKIE_SECURE,
                samesite=COOKIE_SAMESITE
            )
            response.set_cookie(
                key=REFRESH_TOKEN_COOKIE_NAME,
                value=refresh_token,
                expires=timezone.now() + REFRESH_TOKEN_LIFETIME,
                httponly=COOKIE_HTTPONLY,
                secure=COOKIE_SECURE,
                samesite=COOKIE_SAMESITE,
                path=settings.SIMPLE_JWT.get('AUTH_COOKIE_REFRESH_PATH', '/api/token/refresh/') # Set path specific to refresh endpoint
            )
            # Ensure the original tokens aren't in the final response body
            if 'access' in response.data: del response.data['access']
            if 'refresh' in response.data: del response.data['refresh']

        return super().finalize_response(request, response, *args, **kwargs)

# --- Custom Token Refresh Serializer (Reads Cookie) ---
class CookieTokenRefreshSerializer(TokenRefreshSerializer):
    refresh = None # We don't expect 'refresh' in the request body

    def validate(self, attrs):
        # Read refresh token from cookie
        refresh_token_cookie = self.context['request'].COOKIES.get(REFRESH_TOKEN_COOKIE_NAME)

        if not refresh_token_cookie:
            raise InvalidToken('No refresh token found in cookie.')

        attrs['refresh'] = refresh_token_cookie # Pass the cookie value to the parent validator

        # Perform standard refresh token validation
        try:
            data = super().validate(attrs)
        except TokenError as e:
             # Log potentially invalid refresh attempt if needed
             # add_log_entry(None, 'REFRESH_TOKEN_FAIL', {'reason': str(e)}) # User might not be known here
             raise InvalidToken(e.args[0])

        # Don't include the new refresh token in the response body
        # (unless implementing refresh token rotation, which needs careful handling)
        data.pop('refresh', None)
        # Log refresh action if needed (might be noisy)
        # user = User.objects.get(id=jwt_settings.DECODE(data['access'], verify=False)['user_id']) # Decode without verification to get user_id
        # add_log_entry(user, 'TOKEN_REFRESH', {})
        return data

# --- Custom Token Refresh View (Sets Access Cookie) ---
class CookieTokenRefreshView(TokenRefreshView):
    serializer_class = CookieTokenRefreshSerializer

    def finalize_response(self, request, response, *args, **kwargs):
        # If refresh is successful, set the new access token cookie
        if response.status_code == 200 and 'access' in response.data:
            access_token = response.data['access']
            response.set_cookie(
                key=ACCESS_TOKEN_COOKIE_NAME,
                value=access_token,
                expires=timezone.now() + ACCESS_TOKEN_LIFETIME,
                httponly=COOKIE_HTTPONLY,
                secure=COOKIE_SECURE,
                samesite=COOKIE_SAMESITE
            )
            # Remove the access token from the response body
            del response.data['access']

            # Handle refresh token cookie if rotating tokens
            if 'refresh' in response.data:
                 refresh_token = response.data['refresh']
                 response.set_cookie(
                     key=REFRESH_TOKEN_COOKIE_NAME,
                     value=refresh_token,
                     expires=timezone.now() + REFRESH_TOKEN_LIFETIME,
                     httponly=COOKIE_HTTPONLY,
                     secure=COOKIE_SECURE,
                     samesite=COOKIE_SAMESITE,
                     path=settings.SIMPLE_JWT.get('AUTH_COOKIE_REFRESH_PATH', '/api/token/refresh/')
                 )
                 del response.data['refresh']

        # Clear cookies on failure (e.g., invalid refresh token)
        elif response.status_code >= 400:
             response.delete_cookie(ACCESS_TOKEN_COOKIE_NAME)
             response.delete_cookie(REFRESH_TOKEN_COOKIE_NAME, path=settings.SIMPLE_JWT.get('AUTH_COOKIE_REFRESH_PATH', '/api/token/refresh/'))

        return super().finalize_response(request, response, *args, **kwargs)

# --- Logout View (Clears Cookies) ---
class LogoutView(APIView):
    permission_classes = [IsAuthenticated] # Require authentication to logout

    def post(self, request, *args, **kwargs):
        # Log logout action
        add_log_entry(request.user, LogAction.USER_LOGOUT, {'username': request.user.username})

        response = Response({"message": "Logout successful"}, status=status.HTTP_200_OK)
        # Clear the cookies
        response.delete_cookie(ACCESS_TOKEN_COOKIE_NAME)
        response.delete_cookie(REFRESH_TOKEN_COOKIE_NAME, path=settings.SIMPLE_JWT.get('AUTH_COOKIE_REFRESH_PATH', '/api/token/refresh/')) # Use the same path as set during login/refresh
        return response


@api_view(["POST"])
@permission_classes([AllowAny])
def register_user(request):
    email = request.data.get("email")
    username = request.data.get("username")
    password = request.data.get("password")
    bio = request.data.get("bio", "")
    phone = request.data.get("phone", "")
    public_key = request.data.get("public_key", "")
    print(public_key)
    try:
        user = User.objects.create_user(
            username=username,
            email=email,
            password=password,
            bio=bio,
            phone=phone,
            public_key=public_key,
        )
        add_log_entry(user, LogAction.USER_REGISTER, {'email': email, 'username': username})
    except IntegrityError:
        # This typically indicates the username already exists.
        return Response(
            {"error": "Username already exists. Please choose another username."},
            status=status.HTTP_400_BAD_REQUEST
        )

    return Response(
        {"message": "User registered successfully!"},
        status=status.HTTP_201_CREATED
    )

# @api_view(["POST"])
# @permission_classes([AllowAny])
# def login_user(request):
#     email = request.data.get("email")  # Changed from `username`
#     password = request.data.get("password")

#     try:
#         user = User.objects.get(email=email)  # Get user by email
#     except User.DoesNotExist:
#         return Response({"error": "Invalid credentials"}, status=status.HTTP_401_UNAUTHORIZED)

#     if not user.check_password(password):  # Check hashed password
#         return Response({"error": "Invalid credentials"}, status=status.HTTP_401_UNAUTHORIZED)

#     refresh = RefreshToken.for_user(user)  # Generate JWT tokens
#     return Response({
#         "refresh": str(refresh),
#         "access": str(refresh.access_token),
#     }, status=status.HTTP_200_OK)

# Search users by name or bio
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def search_users(request):
    query = request.GET.get('q', '')

    # Get the IDs of users to exclude: current user + existing contacts
    excluded_users = list(request.user.friends.values_list('id', flat=True))  # Get contact IDs
    excluded_users.append(request.user.id)  # Add current user ID

    # Filter users based on query and exclude already added contacts + current user
    users = User.objects.filter(
        Q(username__icontains=query) | Q(bio__icontains=query)
    ).exclude(id__in=excluded_users)

    return Response(UserSerializer(users, many=True).data)

@api_view(["PUT", "PATCH"])
@permission_classes([IsAuthenticated])
def update_profile(request):
    user = request.user
    serializer = UserProfileUpdateSerializer(user, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        add_log_entry(request.user, LogAction.PROFILE_UPDATE, {'updated_fields': list(serializer.validated_data.keys())})
        return Response({"message": "Profile updated successfully!"})
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

# Search User Friends and Groups
@api_view(["GET"])
@permission_classes([IsAuthenticated])
def search_friends_groups(request):
    query = request.GET.get("q", "")
    user = request.user
    # Search among the userâ€™s friends based on username, name, or bio.
    friends = user.friends.filter(
        Q(username__icontains=query) |
        Q(name__icontains=query) |
        Q(bio__icontains=query)
    )
    # Search groups by group name.
    groups = Group.objects.filter(name__icontains=query)
    
    friends_data = UserSerializer(friends, many=True).data
    groups_data = GroupSerializer(groups, many=True).data

    return Response({"friends": friends_data, "groups": groups_data})

# Get All Chats Between Two Parties
@api_view(["GET"])
@permission_classes([IsAuthenticated])
def get_chats(request, user_id):
    """
    Retrieve all chat messages between the logged-in user and the user with the given user_id.
    """
    user = request.user
    other_user = get_object_or_404(User, id=user_id)
    sent_messages = ChatMessage.objects.filter(sender=user, receiver=other_user).order_by("timestamp")
    received_messages = ChatMessage.objects.filter(sender=other_user, receiver=user).order_by("timestamp")
    
    # Serialize messages
    sent_serializer = ChatMessageSerializer(sent_messages, many=True)
    received_serializer = ChatMessageSerializer(received_messages, many=True)
    
    return Response({
        "sent": sent_serializer.data,
        "received": received_serializer.data
    })

# Add Chat Message Between Two Parties
@api_view(["POST"])
@permission_classes([IsAuthenticated])
def send_chat(request):
    """
    Create a new chat message from the logged-in user to the specified receiver.
    """
    sender = request.user
    receiver_id = request.data.get("receiver")
    message = request.data.get("message", "")
    nonce = request.data.get("nonce", "")
    type = request.data.get("type", "")
    fileType = request.data.get("fileType", "")
    fileName = request.data.get("fileName", "")
    if not receiver_id or not message:
        return Response({"error": "Receiver and message are required."}, status=status.HTTP_400_BAD_REQUEST)
    
    receiver = get_object_or_404(User, id=receiver_id)
    chat = ChatMessage.objects.create(sender=sender, receiver=receiver, message=message, nonce=nonce, type=type, fileType=fileType, fileName=fileName)
    serializer = ChatMessageSerializer(chat)
    return Response(serializer.data, status=status.HTTP_201_CREATED)

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def add_contact(request):
    """
    Add a user to the current user's contacts.
    Expects a JSON payload with "contact_id".
    """
    contact_id = request.data.get("contact_id")
    if not contact_id:
        return Response({"error": "contact_id is required."}, status=status.HTTP_400_BAD_REQUEST)
    
    contact = get_object_or_404(User, id=contact_id)
    # Optionally, you can check if the contact is already added.
    if contact in request.user.friends.all():
        return Response({"error": "Contact already added."}, status=status.HTTP_400_BAD_REQUEST)
    add_log_entry(request.user, LogAction.CONTACT_ADD, {'contact_id': contact.id, 'contact_username': contact.username})
    request.user.friends.add(contact)
    return Response({"message": "Contact added successfully!"}, status=status.HTTP_200_OK)

@api_view(["GET"])
@permission_classes([IsAuthenticated])
def list_contacts(request):
    """
    List all contacts (friends) of the current user.
    """
    contacts = request.user.friends.all()
    serializer = UserSerializer(contacts, many=True)
    return Response(serializer.data, status=status.HTTP_200_OK)

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def remove_contact(request):
    """
    Remove a user from the current user's contacts.
    Expects a JSON payload with "contact_id".
    """
    contact_id = request.data.get("contact_id")
    if not contact_id:
        return Response({"error": "contact_id is required."}, status=status.HTTP_400_BAD_REQUEST)
    
    contact = get_object_or_404(User, id=contact_id)
    if contact not in request.user.friends.all():
        return Response({"error": "Contact not found in your contacts."}, status=status.HTTP_400_BAD_REQUEST)
    contact_id_to_log = contact.id # Capture before removing
    contact_username_to_log = contact.username
    request.user.friends.remove(contact)
    add_log_entry(request.user, LogAction.CONTACT_REMOVE, {'contact_id': contact_id_to_log, 'contact_username': contact_username_to_log})
    return Response({"message": "Contact removed successfully!"}, status=status.HTTP_200_OK)

@api_view(["GET", "PATCH"])
@permission_classes([IsAuthenticated])
def profile_view(request):
    """
    GET  -> Returns the non-sensitive data of the logged-in user
    PATCH -> Partially updates the user's profile with provided fields
    """
    if request.method == "GET":
        # Serialize the current user (from the token) without sensitive fields
        serializer = UserProfileSerializer(request.user)
        return Response(serializer.data, status=status.HTTP_200_OK)

    # elif request.method == "PATCH":
    #     # Partially update the user's profile (e.g., bio, phone, etc.)
    #     serializer = UserProfileSerializer(request.user, data=request.data, partial=True)
    #     if serializer.is_valid():
    #         serializer.save()
    #         return Response(serializer.data, status=status.HTTP_200_OK)
    #     return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def send_otp_email(request):
    email = request.data.get("email")
    if not email:
        return Response({"error": "Email is required."}, status=400)

    user = User.objects.filter(email=email).first()
    if not user:
        return Response({"error": "User not found."}, status=404)

    # Generate new OTP
    otp_code = random.randint(100000, 999999)
    otp_obj, created = OTP.objects.update_or_create(
        user=user,
        defaults={
            "otp": otp_code,
            "expires_at": timezone.now() + timedelta(minutes=10)
        }
    )

    print(settings.EMAIL_HOST)
    print(settings.EMAIL_PORT)
    print(settings.EMAIL_HOST_USER)
    print(settings.EMAIL_HOST_PASSWORD)
    print(settings.EMAIL_USE_TLS)
    print(settings.EMAIL_USE_SSL)
    print(settings.DEFAULT_FROM_EMAIL)
    
    # Send OTP email
    try:
        send_mail(
            'Your OTP Code',
            f'Your OTP is {otp_code}. It is valid for 10 minutes.',
            settings.EMAIL_HOST_USER,  # Use Django settings
            [email],
            fail_silently=False,
        )
        add_log_entry(user, LogAction.OTP_REQUEST, {'email': email})
        return Response({"message": "OTP sent successfully."}, status=200)
    except Exception as e:
        return Response({"error": f"Failed to send email: {str(e)}"}, status=500)


# @api_view(["POST"])
# @permission_classes([AllowAny])
# def verify_otp(request):
#     email = request.data.get("email")
#     otp_code = request.data.get("otp")

#     if not email or not otp_code:
#         return Response({"error": "Email and OTP are required."}, status=400)

#     user = User.objects.filter(email=email).first()
#     if not user:
#         return Response({"error": "User not found."}, status=404)

#     otp_obj = OTP.objects.filter(user=user, otp=otp_code).first()

#     if not otp_obj:
#         add_log_entry(user, LogAction.OTP_VERIFY_FAIL, {'reason': 'Invalid OTP', 'email': email})
#         return Response({"error": "Invalid OTP."}, status=400)

#     if not otp_obj.is_valid():
#         add_log_entry(user, LogAction.OTP_VERIFY_FAIL, {'reason': 'Expired OTP', 'email': email})
#         return Response({"error": "OTP has expired."}, status=400)
    
#     add_log_entry(user, LogAction.OTP_VERIFY_SUCCESS, {'email': email})
#     # OTP is valid, proceed with authentication or password reset
#     return Response({"message": "OTP verified successfully."}, status=200)


@api_view(["POST"])
@permission_classes([AllowAny]) # Or IsAuthenticated if OTP verification requires login
def verify_otp(request):
    email = request.data.get("email") # Assuming email is the identifier for now
    otp_code = request.data.get("otp")
    # --- Add verification type ---
    verification_type = request.data.get("type", "").upper() # Expect 'EMAIL' or 'PHONE'

    if not email or not otp_code or not verification_type:
        return Response({"error": "Email, OTP, and type (EMAIL/PHONE) are required."}, status=400)

    if verification_type not in [VerificationRequest.VerificationType.EMAIL, VerificationRequest.VerificationType.PHONE]:
         return Response({"error": "Invalid verification type."}, status=400)

    # Find user by email (adjust if using phone number as identifier for phone OTP)
    user = User.objects.filter(email=email).first()
    if not user:
        return Response({"error": "User not found."}, status=404)

    # --- Check OTP ---
    otp_obj = OTP.objects.filter(user=user, otp=otp_code).first()

    if not otp_obj:
        add_log_entry(user, LogAction.OTP_VERIFY_FAIL, {'reason': 'Invalid OTP', 'identifier': email, 'type': verification_type})
        return Response({"error": "Invalid OTP."}, status=400)

    if not otp_obj.is_valid():
        add_log_entry(user, LogAction.OTP_VERIFY_FAIL, {'reason': 'Expired OTP', 'identifier': email, 'type': verification_type})
        otp_obj.delete() # Delete expired OTP
        return Response({"error": "OTP has expired."}, status=400)

    try:

        verification_request = VerificationRequest.objects.create(
            user=user,
            verification_type=verification_type,
            status=VerificationRequest.VerificationStatus.PENDING
        )

        # Log successful OTP verification *and* the request creation
        add_log_entry(user, LogAction.OTP_VERIFY_SUCCESS, {'identifier': email, 'type': verification_type})
        add_log_entry(user, LogAction.VERIFICATION_REQUESTED, {
            'request_id': verification_request.id,
            'user_id': user.id,
            'type': verification_type
        })

        otp_obj.delete()

        return Response({"message": "OTP verified successfully. Verification pending admin approval."}, status=200)

    except Exception as e:
        add_log_entry(user, LogAction.OTP_VERIFY_FAIL, {'reason': f'Error creating verification request: {str(e)}', 'identifier': email, 'type': verification_type})
        return Response({"error": f"An error occurred: {str(e)}"}, status=500)


@api_view(['GET', 'POST', 'PUT', 'DELETE'])
@permission_classes([IsAuthenticated])
def products(request, product_id=None):
    """
    Handles:
    - GET: Fetch products (all or filtered)
    - POST: Create a new product
    - PUT: Edit an existing product (requires product_id)
    - DELETE: Delete an existing product (requires product_id)
    """

    if request.method == 'GET':
        id = request.GET.get('id')
        query = request.GET.get('q', '')

        products = Product.objects.filter(sold=False)

        if id:
            products = products.filter(user=id)
        elif query:
            products = products.filter(
                Q(name__icontains=query) | Q(description__icontains=query)
            )
        
        print(products)
        serializer = ProductSerializer(products, many=True, context={'request': request})
        return Response(serializer.data)

    elif request.method == 'POST':
        print("Received Data:", request.data)  # Debugging

        user_id = request.data.get("user")  # Expecting User ID now

        print("user_id"+str(user_id))

        try:
            user = User.objects.get(id=user_id)  # Fetch User by ID
        except User.DoesNotExist:
            return Response({"user": ["User not found."]}, status=status.HTTP_400_BAD_REQUEST)

        product_data = request.data.copy()

        serializer = ProductSerializer(data=product_data, context={'request': request})
        if serializer.is_valid():
            serializer.save(user=user)  # Save image explicitly
            product_instance = serializer.save(user=user)
            add_log_entry(request.user, LogAction.PRODUCT_CREATE, {'product_id': product_instance.id, 'name': product_instance.name, 'price': str(product_instance.price)})
            return Response(serializer.data, status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    elif request.method in ['PUT', 'DELETE']:
        if not product_id:
            return Response({"error": "Product ID is required"}, status=status.HTTP_400_BAD_REQUEST)

        product = get_object_or_404(Product, id=product_id)

        # Verify the user owns the product
        if product.user != request.user:
            return Response(
                {"error": "You can only modify your own products"},
                status=status.HTTP_403_FORBIDDEN
            )

        if request.method == 'PUT':
            product_data = request.data.copy()

            serializer = ProductSerializer(product, data=product_data, partial=True, context={'request': request})
            if serializer.is_valid():
                serializer.save()
                updated_product = serializer.save()
                add_log_entry(request.user, LogAction.PRODUCT_UPDATE, {'product_id': updated_product.id, 'updated_fields': list(serializer.validated_data.keys())})                
                return Response(serializer.data)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        elif request.method == 'DELETE':
            if product.user != request.user:
                return Response({"error": "You can only delete your own products"}, status=status.HTTP_403_FORBIDDEN)
            
            product_id_to_log = product.id # Capture before deleting
            product_name_to_log = product.name
            product.delete()
            add_log_entry(request.user, LogAction.PRODUCT_DELETE, {'product_id': product_id_to_log, 'name': product_name_to_log})
            return Response({"message": "Product deleted successfully"}, status=status.HTTP_204_NO_CONTENT)


@api_view(['POST'])
# @authentication_classes([SessionAuthentication, TokenAuthentication])
@permission_classes([IsAuthenticated])
def buy_product(request, product_id):
    product = get_object_or_404(Product, id=product_id)
    buyer = request.user
    seller = product.user

    print("Buyer")
    print(UserSerializer(buyer).data)
    print("Seller")
    print(UserSerializer(seller).data)

    # Prevent self-purchase
    if seller and buyer and seller == buyer:
        return Response({"error": "You cannot purchase your own product."}, status=400)
    
    print("Product")
    print(ProductSerializer(product).data["sold"])

    # Check if already sold
    if product and ProductSerializer(product).data["sold"] == True:
        return Response({"error": "Product is already sold."}, status=400)
    
    # Check if already purchased before starting transaction
    existing_purchase = Purchase.objects.filter(product=product, buyer=request.user).exists()
    if existing_purchase:
        return Response({"error": "You have already purchased this product."}, status=400)

    with transaction.atomic():
        # Rest of the transaction logic
        # Create purchase
        purchase = Purchase.objects.create(
            product=product,
            buyer=buyer,
            purchase_price=product.price
        )
        
        log_details = {
            'product_id': product.id,
            'product_name': product.name,
            'seller_id': seller.id,
            'buyer_id': buyer.id,
            'price': str(product.price),
            'purchase_id': purchase.id
        }
        add_log_entry(buyer, LogAction.PRODUCT_PURCHASE, log_details)

        # Notify the seller
        seller_email = seller.email
        send_mail(
            'Your Product is Sold!',
            f'Your product "{product.name}" has been purchased by {request.user.username}.',
            settings.EMAIL_HOST_USER,
            [seller_email],
            fail_silently=False,
        )   

        # product.delete()
        # Instead of product.delete()
        product.sold = True
        product.save()

    return Response({"message": "Product purchased successfully!"})

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def create_group(request):
    """Create a new group with the current user as admin"""
    name = request.data.get("name")
    members_data = request.data.get("members", [])  # List of {id, encrypted_group_key} dictionaries

    if not name:
        return Response({"error": "Group name is required"}, status=status.HTTP_400_BAD_REQUEST)

    # Check if a group with this name already exists
    if Group.objects.filter(name=name).exists():
        return Response({"error": "A group with this name already exists"}, status=status.HTTP_400_BAD_REQUEST)

    try:
        with transaction.atomic():
            # Create the group with current user as admin
            group = Group.objects.create(name=name, admin=request.user)

            # Ensure the admin is in the members list
            admin_key_data = next((m for m in members_data if str(m["id"]) == str(request.user.id)), None)
            if not admin_key_data:
                return Response({"error": "Admin key missing"}, status=status.HTTP_400_BAD_REQUEST)

            # Add the admin to GroupMembership
            GroupMembership.objects.create(
                user=request.user,
                group=group,
                encrypted_symmetric_key=admin_key_data["encrypted_group_key"]
            )

            # Add other members to the group
            for member_data in members_data:
                if str(member_data["id"]) == str(request.user.id):
                    continue  # Skip the admin (already added)

                try:
                    member = User.objects.get(id=member_data["id"])
                    GroupMembership.objects.create(
                        user=member,
                        group=group,
                        encrypted_symmetric_key=member_data["encrypted_group_key"]
                    )
                except User.DoesNotExist:
                    continue  # Skip missing users

            member_ids = [m['id'] for m in members_data]
            add_log_entry(request.user, LogAction.GROUP_CREATE, {'group_id': group.id, 'group_name': group.name, 'initial_member_ids': member_ids})

            serializer = GroupDetailSerializer(group)
            return Response(serializer.data, status=status.HTTP_201_CREATED)

    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(["POST"])
@permission_classes([IsAuthenticated])
def add_group_member(request, group_id):
    """Add a new member to an existing group"""
    member_id = request.data.get("member_id")
    encrypted_key = request.data.get("encrypted_key")

    if not member_id or not encrypted_key:
        return Response({"error": "Member ID and encrypted key are required"}, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        group = Group.objects.get(id=group_id)
        
        # Check if the user is the admin of the group
        if group.admin != request.user:
            return Response({"error": "Only the group admin can add members"}, status=status.HTTP_403_FORBIDDEN)

        # Check if the member exists
        try:
            member = User.objects.get(id=member_id)
        except User.DoesNotExist:
            return Response({"error": "User does not exist"}, status=status.HTTP_404_NOT_FOUND)
        # Check if the member is already in the group
        if GroupMembership.objects.filter(user=member, group=group).exists():
            return Response({"error": "User is already a member of this group"}, status=status.HTTP_400_BAD_REQUEST)
        
        # Add the member to the group
        GroupMembership.objects.create(
            user=member,
            group=group,
            encrypted_symmetric_key=encrypted_key
        )
        add_log_entry(request.user, LogAction.GROUP_MEMBER_ADD, {'group_id': group.id, 'added_member_id': member.id})

        # Get updated group details including all members
        updated_group_data = GroupDetailSerializer(group).data

        # Return the updated list of members with their encrypted keys
        return Response(updated_group_data, status=status.HTTP_200_OK)

    except Group.DoesNotExist:
        return Response({"error": "Group not found"}, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
@api_view(["DELETE"])
@permission_classes([IsAuthenticated])
def remove_group_member(request, group_id, member_id):
    """Remove a member from a group"""
    try:
        group = Group.objects.get(id=group_id)
        # Check if the user is the admin of the group
        if group.admin != request.user:
            return Response({"error": "Only the group admin can remove members"}, status=status.HTTP_403_FORBIDDEN)
        # Check if the member exists and is in the group
        try:
            member = User.objects.get(id=member_id)
            membership = GroupMembership.objects.get(user=member, group=group)
        except (User.DoesNotExist, GroupMembership.DoesNotExist):
            return Response({"error": "User is not a member of this group"}, status=status.HTTP_404_NOT_FOUND)

        # Cannot remove the admin from their own group
        if member == group.admin:
            return Response({"error": "Cannot remove the group admin"}, status=status.HTTP_400_BAD_REQUEST)
        # Remove the member
        member_id_to_log = member.id # Capture before deleting
        membership.delete()
        add_log_entry(request.user, LogAction.GROUP_MEMBER_REMOVE, {'group_id': group.id, 'removed_member_id': member_id_to_log})
        # After member removal, admin should update encrypted keys for remaining members
        # This happens client-side but we need to provide the updated group data
        updated_group_data = GroupDetailSerializer(group).data
        return Response(updated_group_data, status=status.HTTP_200_OK)
    except Group.DoesNotExist:
        return Response({"error": "Group not found"}, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(["GET"])
@permission_classes([IsAuthenticated])
def get_group_details(request, group_id):
    """Get details of a specific group"""
    try:
        # Check if the user is a member of the group
        membership = GroupMembership.objects.filter(user=request.user, group_id=group_id).first()
        if not membership:
            return Response({"error": "You are not a member of this group"}, status=status.HTTP_403_FORBIDDEN)

        group = membership.group
        serializer = GroupDetailSerializer(group)
        return Response(serializer.data, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(["GET"])
@permission_classes([IsAuthenticated])
def get_group_membership(request, group_id):
    """Retrieve the membership details of the authenticated user in a specific group."""
    try:
        # Fetch the user's membership entry for the given group
        print(request.user)
        print(group_id)
        membership = GroupMembership.objects.filter(user=request.user, group_id=group_id).first()
        group = Group.objects.get(id=group_id)
        admin_id = GroupDetailSerializer(group).data['admin']['id']

        print(UserProfileSerializer(User.objects.get(id=admin_id)))
        admin_public_key = UserProfileSerializer(User.objects.get(id=admin_id)).data["public_key"]
        print(admin_public_key)


        if not membership:
            return Response({"error": "You are not a member of this group"}, status=status.HTTP_403_FORBIDDEN)
        
        new_data_entry = GroupMembershipSerializer(membership).data
        print(new_data_entry)
        new_data_entry["admin_public_key"] = admin_public_key
        print(new_data_entry)
        return Response(new_data_entry, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
@api_view(["GET"])
@permission_classes([IsAuthenticated])
def list_user_groups(request):
    """List all groups where the current user is a member"""
    groups = Group.objects.filter(groupmembership__user=request.user)
    serializer = GroupListSerializer(groups, many=True)
    return Response(serializer.data, status=status.HTTP_200_OK)

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def send_group_message(request, group_id):
    """Send a message to a group"""
    message = request.data.get("message")
    message_type = request.data.get("type", "text")
    file_type = request.data.get("fileType", None)
    file_name = request.data.get("fileName", None)
    if not message:
        return Response({"error": "Message content is required"}, status=status.HTTP_400_BAD_REQUEST)
    try:
        # Check if the user is a member of the group
        membership = GroupMembership.objects.filter(user=request.user, group_id=group_id).first()
        if not membership:
            return Response({"error": "You are not a member of this group"}, status=status.HTTP_403_FORBIDDEN)
        group = membership.group
        # Create and save the message
        group_message = GroupMessage.objects.create(
            group=group,
            sender=request.user,
            message=message,
            type=message_type,
            fileType=file_type,
            fileName=file_name
        )
        log_details = {
            'group_id': group.id,
            'message_id': group_message.id,
            'type': group_message.type,
            'fileName': group_message.fileName # Log file name if applicable
        }
        add_log_entry(request.user, LogAction.GROUP_MESSAGE_SEND, log_details)
        # Return the created message details
        serializer = GroupMessageSerializer(group_message)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
@api_view(["GET"])
@permission_classes([IsAuthenticated])
def get_group_messages(request, group_id):
    """Get all messages from a group"""
    try:
        # Check if the user is a member of the group
        membership = GroupMembership.objects.filter(user=request.user, group_id=group_id).first()
        if not membership:
            return Response({"error": "You are not a member of this group"}, status=status.HTTP_403_FORBIDDEN)
        group = membership.group
        # Get messages with optional pagination
        messages = GroupMessage.objects.filter(group=group).order_by('timestamp')
        # # Add pagination if needed
        # page = request.query_params.get('page')
        # if page:
        #     paginator = Paginator(messages, 50)  # 50 messages per page
        #     try:
        #         messages = paginator.page(page)
        #     except (PageNotAnInteger, EmptyPage):
        #         messages = paginator.page(1)
        serializer = GroupMessageSerializer(messages, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def report_user(request):
    reported_user_id = request.data.get("user_id")
    reason = request.data.get("reason")
    
    if not reported_user_id or not reason:
        return Response({"error": "User ID and reason are required."}, status=status.HTTP_400_BAD_REQUEST)
    
    reported_user = get_object_or_404(User, id=reported_user_id)
    
    # Log the report action
    log_details = {
        'reported_user_id': reported_user_id,
        'reported_username': reported_user.username,
        'reason': reason
    }
    add_log_entry(request.user, LogAction.USER_REPORT, log_details)
    
    return Response({"message": "User reported successfully."}, status=status.HTTP_200_OK)

